import SwiftUI
import PDFKit

// MARK: - PDF Generator

struct PDFGenerator {
    
    static func generateSolutionPDF(
        title: String,
        matrix: [[Fraction]],
        steps: [SolutionStep],
        result: String
    ) -> Data? {
        let pageWidth: CGFloat = 612  // US Letter
        let pageHeight: CGFloat = 792
        let margin: CGFloat = 50
        let contentWidth = pageWidth - 2 * margin
        
        let pdfRenderer = UIGraphicsPDFRenderer(bounds: CGRect(x: 0, y: 0, width: pageWidth, height: pageHeight))
        
        let data = pdfRenderer.pdfData { context in
            context.beginPage()
            
            var yOffset: CGFloat = margin
            
            // Header
            let titleAttributes: [NSAttributedString.Key: Any] = [
                .font: UIFont.boldSystemFont(ofSize: 24),
                .foregroundColor: UIColor.label
            ]
            
            let titleString = NSAttributedString(string: title, attributes: titleAttributes)
            titleString.draw(at: CGPoint(x: margin, y: yOffset))
            yOffset += 40
            
            // Subtitle with date
            let dateFormatter = DateFormatter()
            dateFormatter.dateStyle = .long
            let dateString = "Generated by LinSolve â€¢ \(dateFormatter.string(from: Date()))"
            
            let subtitleAttributes: [NSAttributedString.Key: Any] = [
                .font: UIFont.systemFont(ofSize: 12),
                .foregroundColor: UIColor.secondaryLabel
            ]
            let subtitle = NSAttributedString(string: dateString, attributes: subtitleAttributes)
            subtitle.draw(at: CGPoint(x: margin, y: yOffset))
            yOffset += 30
            
            // Divider line
            let path = UIBezierPath()
            path.move(to: CGPoint(x: margin, y: yOffset))
            path.addLine(to: CGPoint(x: pageWidth - margin, y: yOffset))
            UIColor.separator.setStroke()
            path.stroke()
            yOffset += 20
            
            // Matrix Section
            let sectionAttributes: [NSAttributedString.Key: Any] = [
                .font: UIFont.boldSystemFont(ofSize: 16),
                .foregroundColor: UIColor.label
            ]
            
            let matrixTitle = NSAttributedString(string: "Given Matrix:", attributes: sectionAttributes)
            matrixTitle.draw(at: CGPoint(x: margin, y: yOffset))
            yOffset += 25
            
            yOffset = drawMatrix(matrix, at: CGPoint(x: margin + 20, y: yOffset), in: context.cgContext)
            yOffset += 30
            
            // Steps Section
            let stepsTitle = NSAttributedString(string: "Solution Steps:", attributes: sectionAttributes)
            stepsTitle.draw(at: CGPoint(x: margin, y: yOffset))
            yOffset += 25
            
            for (index, step) in steps.enumerated() {
                // Check if we need a new page
                if yOffset > pageHeight - 150 {
                    context.beginPage()
                    yOffset = margin
                }
                
                // Step number
                let stepNumAttr: [NSAttributedString.Key: Any] = [
                    .font: UIFont.boldSystemFont(ofSize: 14),
                    .foregroundColor: UIColor.systemBlue
                ]
                let stepNum = NSAttributedString(string: "Step \(index + 1): \(step.title)", attributes: stepNumAttr)
                stepNum.draw(at: CGPoint(x: margin, y: yOffset))
                yOffset += 22
                
                // Step description
                let descAttr: [NSAttributedString.Key: Any] = [
                    .font: UIFont.systemFont(ofSize: 12),
                    .foregroundColor: UIColor.label
                ]
                let desc = NSAttributedString(string: step.description, attributes: descAttr)
                let descRect = CGRect(x: margin + 10, y: yOffset, width: contentWidth - 10, height: 100)
                desc.draw(with: descRect, options: [.usesLineFragmentOrigin], context: nil)
                yOffset += 40
                
                // Math expression if present
                if let math = step.math {
                    let mathAttr: [NSAttributedString.Key: Any] = [
                        .font: UIFont(name: "Menlo", size: 12) ?? UIFont.monospacedSystemFont(ofSize: 12, weight: .regular),
                        .foregroundColor: UIColor.label
                    ]
                    let mathStr = NSAttributedString(string: math, attributes: mathAttr)
                    mathStr.draw(at: CGPoint(x: margin + 20, y: yOffset))
                    yOffset += 25
                }
                
                yOffset += 15
            }
            
            // Final Result
            if yOffset > pageHeight - 100 {
                context.beginPage()
                yOffset = margin
            }
            
            let resultPath = UIBezierPath()
            resultPath.move(to: CGPoint(x: margin, y: yOffset))
            resultPath.addLine(to: CGPoint(x: pageWidth - margin, y: yOffset))
            UIColor.separator.setStroke()
            resultPath.stroke()
            yOffset += 15
            
            let resultTitleAttr: [NSAttributedString.Key: Any] = [
                .font: UIFont.boldSystemFont(ofSize: 16),
                .foregroundColor: UIColor.systemGreen
            ]
            let resultTitle = NSAttributedString(string: "Final Result:", attributes: resultTitleAttr)
            resultTitle.draw(at: CGPoint(x: margin, y: yOffset))
            yOffset += 25
            
            let resultAttr: [NSAttributedString.Key: Any] = [
                .font: UIFont(name: "Menlo-Bold", size: 18) ?? UIFont.monospacedSystemFont(ofSize: 18, weight: .bold),
                .foregroundColor: UIColor.label
            ]
            let resultStr = NSAttributedString(string: result, attributes: resultAttr)
            resultStr.draw(at: CGPoint(x: margin + 20, y: yOffset))
        }
        
        return data
    }
    
    static func drawMatrix(_ matrix: [[Fraction]], at origin: CGPoint, in context: CGContext) -> CGFloat {
        let cellWidth: CGFloat = 40
        let cellHeight: CGFloat = 25
        let rows = matrix.count
        let cols = matrix.first?.count ?? 0
        
        let matrixWidth = CGFloat(cols) * cellWidth
        let matrixHeight = CGFloat(rows) * cellHeight
        
        // Draw brackets
        context.saveGState()
        context.setStrokeColor(UIColor.label.cgColor)
        context.setLineWidth(1.5)
        
        // Left bracket
        let leftBracket = UIBezierPath()
        leftBracket.move(to: CGPoint(x: origin.x + 10, y: origin.y))
        leftBracket.addLine(to: CGPoint(x: origin.x, y: origin.y))
        leftBracket.addLine(to: CGPoint(x: origin.x, y: origin.y + matrixHeight))
        leftBracket.addLine(to: CGPoint(x: origin.x + 10, y: origin.y + matrixHeight))
        leftBracket.stroke()
        
        // Right bracket
        let rightX = origin.x + matrixWidth + 20
        let rightBracket = UIBezierPath()
        rightBracket.move(to: CGPoint(x: rightX - 10, y: origin.y))
        rightBracket.addLine(to: CGPoint(x: rightX, y: origin.y))
        rightBracket.addLine(to: CGPoint(x: rightX, y: origin.y + matrixHeight))
        rightBracket.addLine(to: CGPoint(x: rightX - 10, y: origin.y + matrixHeight))
        rightBracket.stroke()
        
        context.restoreGState()
        
        // Draw values
        let valueAttr: [NSAttributedString.Key: Any] = [
            .font: UIFont.monospacedSystemFont(ofSize: 12, weight: .regular),
            .foregroundColor: UIColor.label
        ]
        
        for row in 0..<rows {
            for col in 0..<cols {
                let value = matrix[row][col].description
                let str = NSAttributedString(string: value, attributes: valueAttr)
                let x = origin.x + 15 + CGFloat(col) * cellWidth
                let y = origin.y + 5 + CGFloat(row) * cellHeight
                str.draw(at: CGPoint(x: x, y: y))
            }
        }
        
        return origin.y + matrixHeight
    }
}

// MARK: - Supporting Types

struct SolutionStep {
    var title: String
    var description: String
    var math: String?
    var matrix: [[Fraction]]?
}

// MARK: - Share Sheet

struct ShareSheet: UIViewControllerRepresentable {
    var items: [Any]
    
    func makeUIViewController(context: Context) -> UIActivityViewController {
        UIActivityViewController(activityItems: items, applicationActivities: nil)
    }
    
    func updateUIViewController(_ uiViewController: UIActivityViewController, context: Context) {}
}
